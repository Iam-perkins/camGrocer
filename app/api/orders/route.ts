import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import Order, { IOrder, IOrderItem } from "@/models/Order";
import Store from "@/models/store";
import { sendOrderConfirmationEmail } from "@/lib/email";

// Re-export the OrderItem type for use in this file
type OrderItem = IOrderItem;

// Type definitions for order items
export interface OrderItem {
  productId: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
  storeId: string;
  storeName: string;
}

// Type definition for order
interface OrderType {
  _id: string;
  orderNumber: string;
  userId: string;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  items: OrderItem[];
  subtotal: number;
  shippingFee: number;
  total: number;
  paymentMethod: string;
  paymentStatus: string;
  orderStatus: string;
  shippingAddress: {
    street: string;
    city: string;
    state: string;
    country: string;
    postalCode: string;
  };
  storeIds: string[];
  createdAt: string;
  updatedAt: string;
}

// Helper function to handle errors
const handleError = (error: unknown, message: string) => {
  console.error(message, error);
  return NextResponse.json(
    { error: 'Internal server error' },
    { status: 500 }
  );
};

// POST - Create a new order
export async function POST(request: Request) {
  try {
    const body = await request.json();
    
    // Validate required fields
    const requiredFields = [
      'customerName',
      'customerEmail',
      'customerPhone',
      'shippingAddress',
      'items',
      'paymentMethod'
    ];
    
    const missingFields = requiredFields.filter(field => !body[field]);
    
    if (missingFields.length > 0) {
      console.error('Missing required fields:', missingFields);
      return NextResponse.json(
        { error: `Missing required fields: ${missingFields.join(', ')}` },
        { status: 400 }
      );
    }

    // Calculate order totals
    const subtotal = body.items.reduce((sum: number, item: any) => {
      return sum + (item.price * item.quantity);
    }, 0);
    
    // Use provided shipping fee or default to 1000 FCFA
    const shippingFee = body.shippingFee || 1000;
    const total = subtotal + shippingFee;

    // Extract unique store IDs from items
    const storeIds = [...new Set(body.items.map((item: any) => item.storeId))];

    // Create new order - orderNumber will be generated by the pre-save hook
    const order = new Order({
      userId: body.userId || 'guest',
      customerName: body.customerName,
      customerEmail: body.customerEmail,
      customerPhone: body.customerPhone,
      items: body.items,
      subtotal,
      shippingFee,
      total,
      paymentMethod: body.paymentMethod,
      paymentStatus: 'pending', // Default status
      orderStatus: 'pending',
      shippingAddress: body.shippingAddress,
      storeIds,
      deliveryInstructions: body.deliveryInstructions || '',
      createdAt: new Date(),
      updatedAt: new Date()
    });

    await order.save();

    // Get store owner emails
    const storeOwners = await Store.find({
      _id: { $in: storeIds }
    }).select('owner.email');
    
    const storeOwnerEmails = storeOwners
      .map((store: any) => store.owner?.email)
      .filter((email: string | undefined): email is string => Boolean(email));

    // Prepare order details for email
    const orderDetails = {
      orderNumber: order.orderNumber,
      customerName: order.customerName,
      items: order.items.map((item) => ({
        name: item.name,
        quantity: item.quantity,
        price: item.price,
        storeName: item.storeName
      } as const)),
      subtotal: order.subtotal,
      shippingFee: order.shippingFee,
      total: order.total,
      shippingAddress: order.shippingAddress,
      paymentMethod: order.paymentMethod,
      orderDate: order.createdAt.toISOString()
    };

    // Send confirmation emails (don't await to avoid blocking the response)
    sendOrderConfirmationEmail(
      orderDetails,
      order.customerEmail,
      storeOwnerEmails
    ).catch(error => {
      console.error('Error sending order confirmation emails:', error);
    });

    return NextResponse.json({ 
      message: 'Order created successfully',
      orderId: order._id,
      orderNumber: order.orderNumber
    });
  } catch (error) {
    console.error('Error creating order:', error);
    return NextResponse.json(
      { error: 'Failed to create order' },
      { status: 500 }
    );
  }
}

// GET - Get orders with optional filtering
export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    // Check if user is authenticated
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: "Authentication required" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');
    const storeId = searchParams.get('storeId');
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    const skip = (page - 1) * limit;
    
    let query: any = {};

    // Apply role-based filtering
    if (session.user.role === 'customer') {
      query.userId = session.user.id;
    } else if (session.user.role === 'store' && session.user.storeId) {
      query.storeIds = session.user.storeId;
    }
    // Admin can see all orders

    // Apply status filter if provided
    if (status) {
      query.orderStatus = status;
    }

    // Apply store filter if provided (for admin)
    if (storeId && session.user.role === 'admin') {
      query.storeIds = storeId;
    }

    // Get total count for pagination
    const total = await Order.countDocuments(query);
    
    // Get paginated orders
    const orders = await Order.find(query)
      .sort({ createdAt: -1 }) // Most recent first
      .skip(skip)
      .limit(limit)
      .lean();

    return NextResponse.json({ 
      orders,
      pagination: {
        total,
        page,
        totalPages: Math.ceil(total / limit),
        limit
      }
    });
  } catch (error) {
    console.error('Error fetching orders:', error);
    return NextResponse.json(
      { error: 'Failed to fetch orders' },
      { status: 500 }
    );
  }
}
